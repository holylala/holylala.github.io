[{"title":"Spring Cloud Hystrix 服务容错保护","date":"2019-01-11T14:21:45.000Z","path":"2019/01/11/springcloud-use-hystrix/","text":"Spring Cloud Hystrix Spring Cloud Hystrix 实现了断路器、线程隔离等一系列服务保护功能,基于Netflix的开源框架 Hystrix实现 在服务消费客户端Spring Boot工程pom.xml中引入Spring Cloud Hystrix: 123456&lt;!-- hystrix 熔断器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 在应用主类使用@EnableCircuitBreaker注解开启断路器功能: 1234567891011121314151617@EnableEurekaClient@SpringBootApplication@EnableCircuitBreakerpublic class ConsumerApplication &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; 新增HelloService,添加相关方法: 123456789101112131415161718Servicepublic class HelloService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod=\"helloFallBack\") public String helloService() &#123; String result = restTemplate.getForEntity(\"http://XXX/hello\",String.class).getBody(); return result; &#125; public String helloFallBack() &#123; logger.info(\"helloFallBack going....\"); return \"has error time out maybe\"; &#125;&#125; 修改RibbonConsumerController类,注入实现的HelloService实例: 123456789101112131415@RestControllerpublic class RibbonConsumerController &#123; @Autowired RestTemplate restTemplate; @Autowired HelloService helloService; @RequestMapping(value=\"/ribbon-consumer\",method = RequestMethod.GET) public String helloRibbon() &#123; return helloService.helloService(); &#125;&#125; 服务端模拟服务阻塞(长时间未响应)的情况: 123456789101112131415@RestControllerpublic class HelloController &#123; @RequestMapping(value=\"/hello\",method = RequestMethod.GET) public String hello() throws InterruptedException &#123; //模拟耗时操作,有一定概率发生超时 int sleepTime = new Random().nextInt(3000); Thread.sleep(sleepTime); return \"hello,ribbon hystrix connect ok.\"; &#125;&#125; Hystrix默认超时时间为2000毫秒 消费端调用函数增加调用时长的记录: 1234567891011@HystrixCommand(fallbackMethod=\"helloFallBack\",commandKey = \"helloKey\")public String helloService() &#123; long start = System.currentTimeMillis(); String result = restTemplate.getForEntity(\"http://XXX/hello\",String.class).getBody(); long end = System.currentTimeMillis(); logger.info(\"helloService client connect cost time:\" + (end - start) + \" ms.\"); return result;&#125; 重启HELLO-SERVICE 和 RIBBON-CONSUMER 的实例,通过向 http://127.0.0.1:7012/ribbon-consumer 发起GET请求,获取返回结果: 123456789101112131415161718服务超时返回结果:has error time out maybe服务端日志输出: need cost time:4218ms.消费端日志输出: helloFallBack going.... helloService client connect cost time:4227 ms.服务正常时返回结果:hello,ribbon hystrix connect ok.服务端日志输出: need cost time:206ms.消费端日志输出: helloService client connect cost time:219 ms.","tags":[{"name":"Spring Cloud Hystrix","slug":"Spring-Cloud-Hystrix","permalink":"http://yoursite.com/tags/Spring-Cloud-Hystrix/"},{"name":"容错保护","slug":"容错保护","permalink":"http://yoursite.com/tags/容错保护/"}]},{"title":"Spring Cloud Ribbon 客户端负载均衡的使用","date":"2019-01-10T13:20:45.000Z","path":"2019/01/10/springcloud-use-ribbon/","text":"Spring Cloud Ribbon Spring Cloud Ribbon 是一个基于HTTP和TCP的客户端负载均衡工具,基于Netflix Ribbon实现。 在服务消费客户端Spring Boot工程pom.xml中引入Ribbon模块的依赖: 123456&lt;!--客户端使用负载均衡组件--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 在应用主类通过@EnableEurekaClient注解让该应用注册为Eureka客户端应用,同时在该主类中创建RestTemplate的Spring Bean实例,并通过@LoadBalanced注解开启客户端负载均衡: 12345678910111213141516@EnableEurekaClient@SpringBootApplicationpublic class ConsumerApplication &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; 在工程properties中配置服务注册中心,端口等内容: 1234spring.application.name=xxxxserver.port=xxxxeureka.client.serviceUrl.defaultZone=xx,xx 服务端增加一个可供消费的服务/hello: 12345678910@RestControllerpublic class HelloController &#123; @RequestMapping(value=\"/hello\",method = RequestMethod.GET) public String hello() throws InterruptedException &#123; return \"hello,ribbon connect ok.\"; &#125;&#125; 启动服务端,该服务会注册到指定的注册中心 创建RibbonConsumerController类并实现/ribbon-consumer接口: 12345678910111213@RestControllerpublic class RibbonConsumerController &#123; @Autowired RestTemplate restTemplate; @RequestMapping(value=\"/ribbon-consumer\",method = RequestMethod.GET) public String helloRibbon() &#123; return restTemplate.getForEntity(\"http://服务名(而非具体的访问地址)/hello\",String.class).getBody(); &#125;&#125; 启动ribbon客户端应用,该应用也会注册到指定的服务中心 通过向 http://127.0.0.1:7012/ribbon-consumer 发起GET请求,获取返回结果: 12hello,ribbon connect ok.","tags":[{"name":"Spring Cloud Ribbon","slug":"Spring-Cloud-Ribbon","permalink":"http://yoursite.com/tags/Spring-Cloud-Ribbon/"},{"name":"负载均衡","slug":"负载均衡","permalink":"http://yoursite.com/tags/负载均衡/"}]},{"title":"Spring Cloud Eureka服务治理实践之注册中心的高可用配置","date":"2018-01-10T15:20:45.000Z","path":"2018/01/10/springcloud-eureka-highservice/","text":"高可用注册中心 Eureka Server 的高可用实际上就是将自己作为服务向其他服务注册中心注册自己，这样就可以形成一组相互注册的服务注册中心，以实现服务清单的相互同步，达到高可用的效果。在之前实现的服务注册中心的基础上进行扩展，构建一个双节点的服务注册中心集群。 创建 application-peer1.properties ，修改配置: 123456789#去掉不向自身注册的配置spring.application.name=eureka-server#端口号server.port=1111#该节点名称eureka.instance.hostname=peer1#serviceUrl 指向peer2 另一个节点eureka.client.serviceUrl.defaultZone=http://peer2:1112/eureka/ 创建 application-peer2.properties ，修改配置: 123456789#去掉不向自身注册的配置spring.application.name=eureka-server#端口号server.port=1112#该节点名称eureka.instance.hostname=peer2#serviceUrl 指向peer1 另一个节点eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/ 配置实例名到Url的转换,在window C:\\Windows\\System32\\drivers\\etc 文件中添加映射: 123127.0.0.1 peer1127.0.0.1 peer2 把工程打包，通过 spring.profiles.active 属性分别启动peer1和peer2节点: 123java -jar eurekaserver-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1java -jar eurekaserver-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2 访问 peer1 的注册中心 http://127.0.0.1:1111/ , 如下图所示， 可以到两个节点的注册信息: 同样访问 peer2 的注册中心 http://127.0.0.1:1112/, 如下图所示: 这两个节点,如果有其中一个未启动,后台会有心跳的错误信息输出，同时可在正常节点的控制面板上看到不可用的分片(unavailable-replicas)信息 在设置了多节点的服务注册中心之后,服务提供方需修改相应配置,把服务注册到 Eureka Server集群中，修改 first-service 的 application.properties 配置: 1234spring.application.name=first-service#指向两个节点eureka.client.serviceUrl.defaultZone=http://peer1:1111/eureka/,http://peer2:1112/eureka/ 重新启动 first-service 服务 ，访问 http://127.0.0.1:1111/ 和 http://127.0.0.1:1112/ 发现服务已被同时注册: 若此时断开 peer1 , 在peer2上的其他服务依然能正常访问 first-service","tags":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://yoursite.com/tags/Spring-Cloud-Eureka/"},{"name":"服务治理","slug":"服务治理","permalink":"http://yoursite.com/tags/服务治理/"}]},{"title":"Spring Cloud Eureka服务治理实践之注册服务提供者","date":"2018-01-06T15:20:45.000Z","path":"2018/01/06/springcloud-eureka-registservice/","text":"注册服务提供者 在完成了服务注册中心的搭建之后，将一个既有的Spring Boot 应用加入到 Eureka 的服务治理体系中。 1 将创建的基础Spring Boot 工程进行改造, 将其作为一个微服务应用向服务注册中心发布自己,修改pom.xml，增加Spring Cloud Eureka模块的依赖: 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Camden.SR7&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 2 改造 /hello 请求处理接口, 通过注入 DiscoveryClient 对象 , 打印服务的相关内容日志： 123456789101112131415161718@RestControllerpublic class HelloController &#123; private final Logger logger = Logger.getLogger(getClass()); @Autowired private DiscoveryClient client; @RequestMapping(\"/hello\") public String index() &#123; ServiceInstance instance = client.getLocalServiceInstance(); logger.info(\"/hello, host: \" + instance.getHost() + \", service id: \" + instance.getServiceId() + \", Uri: \" + instance.getUri()); return \"hello world\"; &#125;&#125; 3 在主类中加上 @EnableDiscoveryClient 注解 ，激活 Eureka 中的DiscoveryClient实现,以实现上述Controller中对服务信息的输出 123456789@EnableDiscoveryClient@SpringBootApplicationpublic class HelloApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloApplication.class, args); &#125;&#125; 4 在 application.properties 中增加以下配置: 12345#为服务命名spring.application.name=first-service#指定服务注册中心的地址eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 5 分别启动服务注册中心以及 first-service 服务。在 first-service 服务控制台中, DiscoveryClient对象打印出如下信息，表示服务注册成功 12345s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)c.n.e.EurekaDiscoveryClientConfiguration : Updating port to 8080com.holylala.hello.HelloApplication : Started HelloApplication in 29.214 seconds (JVM running for 41.129)com.netflix.discovery.DiscoveryClient : DiscoveryClient_FIRST-SERVICE/192.168.0.104:first-service - registration status: 204 在服务注册中心的控制台中，有如下信息的输出,代表first-service服务被注册成功: 12c.n.e.registry.AbstractInstanceRegistry : Registered instance FIRST-SERVICE/192.168.0.104:first-service with status UP (replication=false) 通过Eureka的信息面板查看服务的注册信息： 6 http://localhost:8080/hello 请求服务,first-service服务控制台有如下输出: 12com.holylala.hello.HelloController : /hello, host: 192.168.0.104, service id: first-service, Uri: http://192.168.0.104:8080","tags":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://yoursite.com/tags/Spring-Cloud-Eureka/"},{"name":"服务治理","slug":"服务治理","permalink":"http://yoursite.com/tags/服务治理/"}]},{"title":"Spring Cloud Eureka服务治理实践之搭建服务注册中心","date":"2017-12-25T15:20:45.000Z","path":"2017/12/25/springcloud-eureka-servicecenter/","text":"搭建服务注册中心1 首先创建一个基础的 Spring Boot 工程, 命名为eureka-server,并在pom.xml中引入必要的依赖内容: 123456789101112131415161718192021222324252627282930313233343536373839&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Camden.SR7&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 2 通过 @EnableEurekaServer 注解启动一个服务注册中心提供给其他应用进行对话： 1234567891011121314package com.holylala.eurekaserver;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class EurekaserverApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaserverApplication.class, args); &#125;&#125; 3 在默认设置下, 该服务注册中心也会将自己作为客户端来尝试注册它自己,所以需要禁用它的客户端注册行为, 在 application.properties中增加以下配置: 12345678server.port=1111eureka.instance.hostname=localhost#不向注册中心注册自己eureka.client.register-with-eureka=false#维护自身的服务实例,不需要去检索服务eureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 4 启动应用并访问 http://localhost:1111,可以看到如下图显示的 Eureka 信息面板: Instances currently registered with Eureka 一栏显示 No instances available 说明该注册中心还没有注册任何服务。","tags":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://yoursite.com/tags/Spring-Cloud-Eureka/"},{"name":"服务治理","slug":"服务治理","permalink":"http://yoursite.com/tags/服务治理/"}]},{"title":"模式的秘密-代理模式","date":"2017-12-18T14:15:45.000Z","path":"2017/12/18/java-pattern-proxy/","text":"代理模式定义为其他对象提供一种代理以控制对这个对象的访问。代理对象起到中介作用，可去掉功能服务或者增加额外的服务。 常见的几种代理模式 远程代理 为不同地理的对象提供局域网代表对象 虚拟代理 根据需要将资源消耗很大的对象进行延迟,真正需要的时候进行创建 保护代理 权限控制 智能引用代理 提供额外功能 智能引用代理的实现 静态代理 代理和被代理对象在代理之前是确定的。他们都实现相同的接口或者继承相同的抽象类。 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//功能接口public interface Moveable &#123; void move();&#125;//功能实现对象public class Car implements Moveable &#123; @Override public void move() &#123; //实现开车 try &#123; Thread.sleep(new Random().nextInt(1000)); System.out.println(\"汽车行驶中....\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;//使用继承实现代理 TimeCounter1 是 Car 的代理public class TimeCounter1 extends Car &#123; @Override public void move() &#123; long starttime = System.currentTimeMillis(); System.out.println(\"汽车开始行驶....\"); super.move(); long endtime = System.currentTimeMillis(); System.out.println(\"汽车结束行驶.... 汽车行驶时间：\" + (endtime - starttime) + \"毫秒！\"); &#125;&#125;//使用聚合实现代理 TimeCounter1 是 Car 的代理public class TimeCounter2 implements Moveable &#123; public TimeCounter2(Car car) &#123; super(); this.car = car; &#125; private Car car; @Override public void move() &#123; long starttime = System.currentTimeMillis(); System.out.println(\"汽车开始行驶....\"); car.move(); long endtime = System.currentTimeMillis(); System.out.println(\"汽车结束行驶.... 汽车行驶时间：\" + (endtime - starttime) + \"毫秒！\"); &#125;&#125;//调用 //使用继承的方式 Moveable m = new TimeCounter1(); m.move(); //使用聚合方式实现 Car car = new Car(); Moveable m1 = new TimeCounter2(car); m1.move();","tags":[{"name":"pattern","slug":"pattern","permalink":"http://yoursite.com/tags/pattern/"},{"name":"proxy","slug":"proxy","permalink":"http://yoursite.com/tags/proxy/"}]},{"title":"Java NIO 中的 Buffer","date":"2017-12-18T13:12:45.000Z","path":"2017/12/18/java-nio-buffer/","text":"Buffer 的基本原理Buffer中有3个重要的参数:位置（position),容量（capacity) 和上限(limit)。这三者的含义如下图描述: 示例: 1234567891011121314151617181920212223ByteBuffer b = ByteBuffer.allocate(15);System.out.println(\"初始值\\tlimit=\"+b.limit()+\"\\tcapacity=\"+b.capacity()+\"\\tposition=\"+b.position());//存入10个字节数据for (int i = 0; i &lt; 10; i++) &#123; b.put((byte)i);&#125;System.out.println(\"存入10个字节数据之后\\tlimit=\"+b.limit()+\"\\tcapacity=\"+b.capacity()+\"\\tposition=\"+b.position());//重置positionb.flip();System.out.println(\"Buffer重置之后\\tlimit=\"+b.limit()+\"\\tcapacity=\"+b.capacity()+\"\\tposition=\"+b.position());for (int i = 0; i &lt; 5; i++) &#123; System.out.print(b.get());&#125;System.out.println();System.out.println(\"Buffer取5个值之后\\tlimit=\"+b.limit()+\"\\tcapacity=\"+b.capacity()+\"\\tposition=\"+b.position());b.flip();System.out.println(\"Buffer再次重置之后\\tlimit=\"+b.limit()+\"\\tcapacity=\"+b.capacity()+\"\\tposition=\"+b.position()); 以上代码首先分配了一个15个字节大小的缓冲。初始阶段，如下图显示， postion 为 0 , capacity 为 15, limit 为15, 这里索引为15的位置实际上是不存在的。 接着, Buffer中存入10个byte, 当前position的位置会向前移动,因为position位置始终指向下一个即将输入的位置,所以 position 变为 10, 而 limit 和 capacity 不变。 接着执行 flip() 操作, 该操作会重置 position , 通常将Buffer从写模式转换成读模式时需要执行此方法。flip() 操作不仅重置了当前的position为0，还将limit设置到当前position的位置，这样做的目的是防止在读模式中,读到应用程序根本没有进行操作的区域。 接着执行5次读操作,和写操作一样，读操作也会设置 position 到当前位置，如下图： 最后,再执行一次 flip(),将 position 归零,同时将limit设置到position的位置： 程序输出如下： 1234567初始值 limit=15 capacity=15 position=0存入10个字节数据之后 limit=15 capacity=15 position=10Buffer重置之后 limit=10 capacity=15 position=001234Buffer取5个值之后 limit=10 capacity=15 position=5Buffer再次重置之后 limit=5 capacity=15 position=0","tags":[{"name":"Java NIO","slug":"Java-NIO","permalink":"http://yoursite.com/tags/Java-NIO/"},{"name":"Buffer","slug":"Buffer","permalink":"http://yoursite.com/tags/Buffer/"}]},{"title":"Spring Cloud Eureka服务治理实践之构建Spring Boot基础项目","date":"2017-12-17T11:12:45.000Z","path":"2017/12/17/springcloud-eureka/","text":"前言Spring Cloud Eureka 是 Spring Cloud Netflix 微服务套件中的一部分,它基于Netflix EureKa 做了二次封装，主要负责完成微服务架构中的服务治理功能。服务治理可以说是微服务架构中最为核心和基础的模块,它主要用来实现各个微服务实例的自动化注册与发现。 微服务构建 Spring Boot 基础项目1.系统及工具版本 jdk1.8.0_73 Maven 3.3 Spring Boot 1.4.7 IntelliJ IDEA 15.0.1 2.构建 Maven 项目 通过官方的 Spring Initializr 工具来产生基础项目 访问 http://start.spring.io/ , 如下图指示,生成项目包 在IDE中以Maven项目导入,Project from Existing Sources … 选择项目文件夹 3.项目结构 4.Maven配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.holylala&lt;/groupId&gt; &lt;artifactId&gt;hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Spring Boot 默认将该Web应用打包为jar的形式,而非war的形式，因为默认的Web模块依赖会包含嵌入式的Tomcat。 spring-boot-starter-web ：全栈Web开发模块,包含嵌入式Tomcat,Spring MVC spring-boot-starter-test： 通用测试模块,包含Junit 5 实现RESTful API 1234567891011121314package com.holylala.hello;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;//注意该类的目录结构 需放在com.holylala.hello包下@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String index() &#123; return &quot;hello world&quot;; &#125;&#125; 6 启动 Spring Boot 应用 mvn spring-boot:run 在服务器上部署运行时,通常先使用 mvn install 将应用打包成jar包,再通过 java -jar xxx.jar 来启动应用。 7 项目访问 访问 http://127.0.0.1:8080/hello ，可看到返回了预期结果: hello world","tags":[{"name":"Spring Cloud Eureka","slug":"Spring-Cloud-Eureka","permalink":"http://yoursite.com/tags/Spring-Cloud-Eureka/"},{"name":"服务治理","slug":"服务治理","permalink":"http://yoursite.com/tags/服务治理/"}]},{"title":"RabbitMQ中的几种交换器","date":"2017-11-30T11:12:45.000Z","path":"2017/11/30/rabbitmq-msgtype/","text":"前言RabbitMQ会根据路由键将消息从交换器路由到队列,但它是如何处理投递到多个队列的情况的呢？协议中定义的不同类型交换器发挥了作用。最常用的一共有三种类型：direct,fanout和topic。 direct交换器direct交换器非常简单:如果路由键匹配的话,消息就被投递到对应的队列,请参考下图 服务器必须实现direct类型交换器，包含一个空白字符串名称的默认交换器。当声明一个队列时，它会自动绑定到默认交换器，并以队列名称作为路由键。当默认的direct交换器无法满足应用程序的需求时,你可以声明你自己的交换器。 fanout交换器 这种类型的交换器会将收到的消息广播到绑定的队列上。当发送一条消息到fanout交换器时,它会把消息投递给所有附加在此交换器上的队列。实现对单条消息做不同方式的处理。 topic交换器 这类交换器可以使得来自不同源头的消息能够到达同一个队列,它能基于多个规则或标准进行路由,是一种更为灵活的交换器。发送到topic型交换器的消息不能包含任意路由键——它必须是一串字符并且以圆点符号隔开。这些字符可以是任意的，但它们通常都会指定成链接的消息的某些功能。一些有效的路由键如：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”等，路由键可以包括任意多个字符，上限是255个字节长度。绑定键也必须使用类似的形式。topic型交换器的逻辑和direct型很相像——消息发送时会指定一个特别的路由键，并且会被路由到所有与绑定键相匹配的队列。不过对绑定键有两种特殊类型： ”*” 符号用来代替任意单词 ”#” 符号可以代替0个或多个单词 topic类型交换器灵活之处体现在： 当一个队列以”#”作为绑定键时，它将接收所有消息，而不管路由键如何，类似于fanout型交换器 当特殊字符”*”、”#”没有用到绑定时，topic型交换器就好比direct型交换器了","tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"}]},{"title":"使用Redis+Lua实现分布式限流","date":"2017-07-01T15:14:40.000Z","path":"2017/07/01/redis-lua-distributed-limit/","text":"分布式限流分布式限流最关键的是要将限流服务做成原子化,而解决方案可以使用 Redis+Lua 或者 Nginx+Lua 技术实现,通过这两种技术可以实现高并发和高性能。本文使用 Redis+Lua 实现时间窗内某个接口的请求数限流，实现了该功能后可以改造为限流总并发/请求数和限制总资源数。 Redis+Lua实现脚本 12345678910local key = KEYS[1] #限流KEY（一秒一个）local limit = tonumber(ARGV[1]) #限流大小local current = tonumber(redis.call('get',key) or \"0\") #获取不到 默认为0if current + 1 &gt; limit then #如果超出限流大小 return 0else #请求数+1，并设置2秒过期 redis.call(\"INCRBY\",key,\"1\") redis.call(\"expire\",key,\"2\") return 1end Java中判断是否需要限流的代码1234567891011public static boolean distributedLimit() throws Exception &#123; //redis lua 脚本 String luaScript = Files.toString(new File(\"xxxxLimit.lua\")),Charset.defaultCharset()); //将当前时间戳取秒数（极端情况下机器时钟不准时会存在一些小问题) String key = \"ip:\" + System.currentTimeMillis()/1000; //限流大小 String limit = \"30\"; //执行脚本 return (Long)jedis.eval(luaScript,Lists.newArrayList(key),Lists.newArrayList(limit)) == 1;&#125;","tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"},{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/tags/Lua/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/tags/分布式/"}]},{"title":"Python数据分析:Kaggle案例之StarCraft II Replay Analysis","date":"2017-05-14T15:37:01.000Z","path":"2017/05/14/python-da-kagglepro-starwar/","text":"1.Project Detail 项目地址: &gt;&gt;&gt; 数据来源: 下载 starcraft.csv(This dataset is an aggregate of the screen-fixations from screen movements of StarCraft 2 replay files) , 共21列数据 Inspiration: 分析每个战队的APM(Action per minute)和HoursPerWeek(Hours spent playing per week) 2.Code Say 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181# coding:utf-8# main.py# 引入必要的库 pandas_tools:封装的工具import pandas as pdfrom pandas_tools import inspect_dataset, visualize_league_attributes,\\ visualize_league_attribute_stats, process_missing_datadataset_path = './dataset/starcraft.csv' ##指定需要分析数据文件路径def run_main(): \"\"\" 主函数 \"\"\" ## Step.0 加载数据 df_data = pd.read_csv(dataset_path) ## Step.1 查看数据 数据预览 inspect_dataset(df_data) ## Step.2 处理缺失数据 设置默认值 df_data = process_missing_data(df_data) ## Step.3.1 可视化战队属性，散点图 column_names = ['LeagueIndex', # 战队索引号 'HoursPerWeek', # 每周游戏时间 'Age', # 战队中玩家的年龄 'APM', # 操作速度(技术能力) 'WorkersMade' # 单位时间的建造数 ] visualize_league_attributes(df_data[column_names]) ## list 不连续索引 ## Step3.2 可视化战队属性统计值 visualize_league_attribute_stats(df_data[column_names], 'APM', savedata_path='./league_apm_stats.csv', savefig_path='./league_apm_stats.png',) visualize_league_attribute_stats(df_data[column_names], 'HoursPerWeek', savedata_path='./league_hrs_stats.csv', savefig_path='./league_hrs_stats.png',) # 运行入口if __name__ == '__main__': run_main()# ---------------------------------------------------------------------------------------------# pandas_tools.pyimport matplotlib.pyplot as pltimport pandas as pdimport matplotlib.patches as mpatchesdef inspect_dataset(df_data): \"\"\" 查看加载的数据基本信息 \"\"\" print '数据集基本信息：' print df_data.info() print '数据集有%i行，%i列' %(df_data.shape[0], df_data.shape[1]) print '数据预览:' print df_data.head()def process_missing_data(df_data): \"\"\" 处理缺失数据 \"\"\" if df_data.isnull().values.any(): # 存在缺失数据 df_data = df_data.fillna(0.) # 填充nan# df_data = df_data.dropna() # 过滤nan return df_data def visualize_league_attributes(df_data, save_fig = True): \"\"\" 可视化战队属性 \"\"\" # 创建figure 放四张图 fig = plt.figure(figsize=(15.0, 10.0)) ax1 = fig.add_subplot(2,2,1) ax2 = fig.add_subplot(2,2,2) ax3 = fig.add_subplot(2,2,3) ax4 = fig.add_subplot(2,2,4) # 解决matplotlib显示中文问题 plt.rcParams['font.sans-serif'] = ['SimHei'] #指定默认字体 plt.rcParams['axes.unicode_minus'] = False #解决保存图像是负号'-'显示为方块的问题 fig.suptitle(u'战队属性') #给图起个标题 # 画散点图 横轴战队 纵轴每周游戏时间 ax1.scatter(df_data['LeagueIndex'], df_data['HoursPerWeek']) ax1.set_xlabel(u'战队') ax1.set_ylabel(u'每周游戏时间') ax2.scatter(df_data['LeagueIndex'], df_data['Age']) ax2.set_xlabel(u'战队') ax2.set_ylabel(u'玩家年龄') ax3.scatter(df_data['LeagueIndex'], df_data['APM']) ax3.set_xlabel(u'战队') ax3.set_ylabel(u'APM') ax4.scatter(df_data['LeagueIndex'], df_data['WorkersMade']) ax4.set_xlabel(u'战队') ax4.set_ylabel(u'单位时间建造数') if save_fig: plt.savefig('./league_attributes.png') #数据存储 plt.show() def visualize_league_attribute_stats(df_data, attr_label, savedata_path = '', savefig_path = ''): \"\"\" 可视化战队属性统计值 1到8 战队数 \"\"\" league_idx_lst = range(1,9) # 统计最小值 最大值 和均值 stats_min = [] stats_max = [] stats_mean = [] for league_idx in league_idx_lst: # 处理每一个战队的数据 # 数据选取 loc 标签索引 df_data['LeagueIndex'] == league_idx 行索引,true or false 只取满足条件的数据 attr_label:列索引 filtered_data = df_data.loc[df_data['LeagueIndex'] == league_idx, attr_label] stats_min.append(filtered_data.min()) stats_max.append(filtered_data.max()) stats_mean.append(filtered_data.mean()) league_ser = pd.Series(league_idx_lst, name='LeagueIndex') # 把各战队编号list变成series stats_min_ser = pd.Series(stats_min, name='min') # 把各战队统计数据list变成series stats_max_ser = pd.Series(stats_max, name='max') stats_mean_ser = pd.Series(stats_mean, name='mean') #把Series拼装成DataFrame axis=1 指定轴方向 横向拼接 df_result = pd.concat([league_ser, stats_min_ser, stats_max_ser, stats_mean_ser], axis=1) #数据保存 if savedata_path != '': df_result.to_csv(savedata_path, index=None) # 统计值可视化 # 创建figure fig = plt.figure(figsize=(15.0, 10.0)) fig.add_subplot(1,1,1) # 解决matplotlib显示中文问题 plt.rcParams['font.sans-serif'] = ['SimHei'] #指定默认字体 plt.rcParams['axes.unicode_minus'] = False #解决保存图像是负号'-'显示为方块的问题 plt.plot(df_result['LeagueIndex'], df_result['mean'], color='b') plt.plot(df_result['LeagueIndex'], df_result['min'], color='g') plt.plot(df_result['LeagueIndex'], df_result['max'], color='r') plt.xlabel(u\"战队\") plt.ylabel(attr_label) plt.title(attr_label + u\"--Lqian\") #添加图例 blue_patch = mpatches.Patch(color='blue', label=u\"均值 \" + attr_label) green_patch = mpatches.Patch(color='green', label=u'最小值 '+ attr_label) red_patch = mpatches.Patch(color='red', label=u'最大值 '+ attr_label) plt.legend(handles=[blue_patch, green_patch, red_patch], loc=2) if savefig_path != '': plt.savefig(savefig_path) plt.show() 3.战队属性散点图 4.战队APM 5.战队每周游戏时间 6.结论孰能生巧，Skill comes of practice.","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"纯代码","slug":"纯代码","permalink":"http://yoursite.com/tags/纯代码/"},{"name":"kaggle","slug":"kaggle","permalink":"http://yoursite.com/tags/kaggle/"},{"name":"pandas","slug":"pandas","permalink":"http://yoursite.com/tags/pandas/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://yoursite.com/tags/matplotlib/"}]},{"title":"走进Docker之Docker初识","date":"2017-04-30T17:34:03.000Z","path":"2017/05/01/docker-whatis/","text":"Docker历史 2010 dotCloud PAAS 2013 docker开源 2015.4 D轮 2014.6 Docker 1.0 2014.7 C轮 Now:free Community Edition (CE) and as a subscription in Enterprise Edition (EE) What’s Docker Docker is the world’s leading software container platform 开源 , 跨平台 技术核心 镜像： 集装箱 仓库 ： 码头 容器 ： 运行程序的地方 简单理解就是去仓库把镜像下到本地，用命令把镜像运行起来变成容器。 Docker仓库 官方库: &gt;&gt;&gt; 网 易: &gt;&gt;&gt;","tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"Python数据分析:Kaggle案例之2016 Election Pools","date":"2017-04-30T15:58:01.000Z","path":"2017/04/30/python-da-kagglepro-elepolls/","text":"1.Project Detail 地址: &gt;&gt;&gt;(建议翻墙) 数据来源: 下载 presidential_polls.csv(This dataset is a collection of state and national polls conducted from November 2015-November 2016 on the 2016 presidential election) , 共27列数据 Inspiration: 分析每个月的民意调查统计趋势 2.撸代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164# coding:utf-8# 引入必要的库import numpy as npimport datetimeimport matplotlib.pyplot as plt# 判断一个字符串能否转换为floatdef is_convert_float(s): try: float(s) except: return False return Truedef get_sum(str_array): \"\"\" 返回字符串数组中数字的总和 \"\"\" # 去掉不能转换成数字的数据 cleaned_data = filter(is_convert_float, str_array) # 转换数据类型 float_array = np.array(cleaned_data, np.float) return np.sum(float_array)def run_main(): \"\"\" main function \"\"\" # 数据文件地址 filename = './presidential_polls.csv' ## Step1. 列名预处理 # 读取列名，即第一行数据 r:代表读取 f：代表打开的文件 with open(filename, 'r') as f: col_names_str = f.readline()[:-1] # [:-1]表示不读取末尾的换行符'\\n' 读取标题行 cycle,branch,... # 将字符串拆分，并组成列表 col_name_lst = col_names_str.split(',') # 使用的列名： 统计截止时间,克林顿民意数据,川普民意数据,克林顿校准民意数据,川普校准民意数据 use_col_name_lst = ['enddate', 'rawpoll_clinton', 'rawpoll_trump','adjpoll_clinton', 'adjpoll_trump'] # 获取相应列名的索引号 use_col_index_lst = [col_name_lst.index(use_col_name) for use_col_name in use_col_name_lst] ## Step2. 读取数据 data_array = np.loadtxt(filename, # 文件名 delimiter=',', # 分隔符 skiprows=1, # 跳过第一行，即跳过列名 dtype=str, # 数据类型 usecols=use_col_index_lst) # 指定读取的列索引号 ## Step3. 数据处理 # 处理日期格式数据 enddate_idx = use_col_name_lst.index('enddate') enddate_lst = data_array[:,enddate_idx].tolist() #拿到多维数组中某一列的数据 并转换成列表 # 将日期字符串格式统一，即'yy/dd/mm' enddate_lst = [enddate.replace('-', '/') for enddate in enddate_lst] # 将日期字符串转换成日期 date_lst = [datetime.datetime.strptime(enddate, '%m/%d/%Y') for enddate in enddate_lst] print data_array[:20] # ['10/30/2016' '45' '46' '43.29659' '44.72984'] # 构造年份-月份 字符列表 month_lst = ['%d-%02d' %(date_obj.year, date_obj.month) for date_obj in date_lst] month_array = np.array(month_lst) months = np.unique(month_array) #去掉重复的年 月 ## Step4. 数据分析 # 统计民意投票数 # 克林顿 # 原始数据 rawpoll 拿到指定列的全部数据 rawpoll_clinton_idx = use_col_name_lst.index('rawpoll_clinton') rawpoll_clinton_data = data_array[:, rawpoll_clinton_idx] # 调整后的数据 adjpool adjpoll_clinton_idx = use_col_name_lst.index('adjpoll_clinton') adjpoll_clinton_data = data_array[:, adjpoll_clinton_idx] # 川普 # 原始数据 rawpoll rawpoll_trump_idx = use_col_name_lst.index('rawpoll_trump') rawpoll_trump_data = data_array[:, rawpoll_trump_idx] # 调整后的数据 adjpoll adjpoll_trump_idx = use_col_name_lst.index('adjpoll_trump') adjpoll_trump_data = data_array[:, adjpoll_trump_idx] # 结果保存 results = [] #遍历唯一的年月 for month in months: # clinton # 原始数据 rawpoll rawpoll_clinton_month_data = rawpoll_clinton_data[month_array == month] # 统计当月的总票数 rawpoll_clinton_month_sum = get_sum(rawpoll_clinton_month_data) # 调整数据 adjpoll adjpoll_clinton_month_data = adjpoll_clinton_data[month_array == month] # 统计当月的总票数 adjpoll_clinton_month_sum = get_sum(adjpoll_clinton_month_data) # trump # 原始数据 rawpoll rawpoll_trump_month_data = rawpoll_trump_data[month_array == month] # 统计当月的总票数 rawpoll_trump_month_sum = get_sum(rawpoll_trump_month_data) # 调整数据 adjpoll adjpoll_trump_month_data = adjpoll_trump_data[month_array == month] # 统计当月的总票数 adjpoll_trump_month_sum = get_sum(adjpoll_trump_month_data) results.append((month, rawpoll_clinton_month_sum, adjpoll_clinton_month_sum, rawpoll_trump_month_sum, adjpoll_trump_month_sum)) print results months, raw_cliton_sum, adj_cliton_sum, raw_trump_sum, adj_trump_sum = zip(*results) ## Step5. 可视化分析结果 fig, subplot_arr = plt.subplots(2,2, figsize=(15,10)) # 原始数据趋势展示 subplot_arr[0,0].plot(raw_cliton_sum, color='r') subplot_arr[0,0].plot(raw_trump_sum, color='g') width = 0.25 x = np.arange(len(months)) subplot_arr[0,1].bar(x, raw_cliton_sum, width, color='r') subplot_arr[0,1].bar(x + width, raw_trump_sum, width, color='g') subplot_arr[0,1].set_xticks(x + width) subplot_arr[0,1].set_xticklabels(months, rotation='vertical') # 调整数据趋势展示 subplot_arr[1,0].plot(adj_cliton_sum, color='r') subplot_arr[1,0].plot(adj_trump_sum, color='g') width = 0.25 x = np.arange(len(months)) subplot_arr[1,1].bar(x, adj_cliton_sum, width, color='r') subplot_arr[1,1].bar(x + width, adj_trump_sum, width, color='g') subplot_arr[1,1].set_xticks(x + width) subplot_arr[1,1].set_xticklabels(months, rotation='vertical') plt.subplots_adjust(wspace=0.2) plt.show()# 运行入口if __name__ == '__main__': run_main() 3.数据分析结果(红色克林顿绿色川普) 4.结论一切都是命中注定，He says that everything is predetermined.","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"纯代码","slug":"纯代码","permalink":"http://yoursite.com/tags/纯代码/"},{"name":"kaggle","slug":"kaggle","permalink":"http://yoursite.com/tags/kaggle/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://yoursite.com/tags/matplotlib/"},{"name":"numpy","slug":"numpy","permalink":"http://yoursite.com/tags/numpy/"}]},{"title":"搭建Python开发环境(win10)","date":"2017-04-29T10:44:31.000Z","path":"2017/04/29/build-python-devenv/","text":"安装Anaconda2 版本: 4.3.1-Windows-x86_64 (选择Python3.6 or Python2.7) 安装地址: &gt;&gt; 安装 JetBrains PyCharm 版本: PyCharm Professional Edition 安装地址: &gt;&gt;, 安装时选择自动配置Python环境变量 PyCharm设置 在New Project的Interpreter中指定python.exe路径 Anaconda常用命令12345678python --vesion ipython #交互式命令行 Shell jupyter notebook #cd到.ipynb文件目录 启动jupyterexit 让Python带你飞","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"在redis中使用Lua脚本","date":"2017-04-28T15:40:21.000Z","path":"2017/04/28/redis-uselua/","text":"脚本介绍Redis在2.6版本中推出了脚本功能,使用Lua语言(一种“卫星语言”,能够方便地嵌入到其他语言中使用)编写脚本传到Redis中执行。在Lua脚本中可以调用大部分的Redis命令,使用脚本的好处如下: 减少网络开销: 多个redis请求可以在一个脚本中一次发送一个请求,减少网络往返时延。 原子操作: Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。编写脚本的过程中无需担心会出现竞态条件,也就无需使用事务。事务可以完成的所有功能都可以用脚本实现。 复用: 客户端发送的脚本会永久存储在Redis中,其他语言开发的项目可以复用之。 代码示例1.访问频率限制123456789101112131415161718local times = redis.call('incr',KEYS[1])if times == 1 then #KEYS[1]键刚创建,所以为其设置生存时间redis.call('expire',KEYS[1],ARGV[1])end if times &gt; tonumber(ARGV[2]) then return 0end return 1 #保存该脚本为test.lua,执行该脚本:redis-cli --eval /path/test.lua key1 , 10 2#--eval参数是告诉redis-cli读取并运行后面的Lua脚本,/path/test.jua是脚本文件的路径,key1是要操作的键，在脚本中使用KEYS[1]获取,10和2是参数，在脚本中使用ARGV[1]和ARGV[2]获得值（每10秒最多访问3次),注意空格 2.java代码示例123456789101112131415//redis lua 脚本static String luaScript = \"local timeValue = redis.call('get',KEYS[1]) if timeValue &lt; ARGV[1] then return redis.call('mset',KEYS[1],ARGV[1],KEYS[2],ARGV[2]) end return nil\";//执行脚本redisClient.executeLuaScript(luaScript,\"key1\", \"key2\", \"value1\", \"value2\");//executeLuaScript方法:public Object executeLuaScript(String script,String key1,String key2,String avg1,String avg2) throws Exception &#123; return this.execution(new JedisResultTask() &#123; protected Object doExecution(Jedis jedis) &#123; return jedis.eval(script,2,key1,key2,avg1,avg2); &#125; &#125;); &#125; 3.解决抢红包高并发的问题 传送门","tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"},{"name":"Lua","slug":"Lua","permalink":"http://yoursite.com/tags/Lua/"}]},{"title":"在Redis中使用管道","date":"2017-04-23T11:12:45.000Z","path":"2017/04/23/redis-usepip/","text":"使用场景客户端和Redis使用TCP协议连接。不论是客户端向Redis发送命令还是Redis向客户端返回命令的执行结果,都需要进过网络传输,这两部分的总耗时称为往返时延。大致来说到本地回环地址(loop back address)的往返时延在数据量级上相当于Redis处理一条简单命令的时间。如果执行较多的命令,每个命令的往返时延累加起来对性能还是有一定影响的。 在执行多个命令时每条命令都需要等待上一条命令执行完才能执行,即使命令不需要上一条命令的执行结果。Redis的底层通信协议对管道(pipelining)提供了支持。通过管道可以一次性发送多条命令并在执行完成后一次性将结果返回，当一组命令中每条命令都不依赖于之前命令的执行结果时就可以将这组命令一起通过管道发出。管道通过减少客户端与Redis的通信次数来实现降低往返时延累计值的目的。 简单概括两点就是: 多个命令之间没有依赖关系,每个命令只需单独执行 对响应时间要求苛刻 不使用管道时命令执行示意图（纵向表示时间） 使用管道时命令执行示意图 java代码示例1234567891011121314redisClient.executionPipelinedExt(new Redis.JedisResultTask&lt;Object&gt;() &#123; @Override protected Object doExecution(Jedis jedis) &#123; Pipeline pipeline = jedis.pipelined(); pipeline.set(“key1”,“value1”); pipeline.set(“key2”,“value2”); pipeline.set(“key3”,“value3”); ... pipeline.sync(); return null; &#125; &#125;); Python代码示例(使用redis-py) 12345678910111213141516171819import redisr = redis.StrictRedis()# redis-py的事务使用方式如下:pipe = r.pipeline()pipe.set('key1','value1')pipe.get('key1')result = pipe.execute()print result# 管道的使用方式和事务相同,只不过需要在创建时加上参数transaction=False:pipe = r.pipeline(transaction=False)# 支持链式调用r.pipeline().set('key1','value1').get('key1').execute()","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"HEXO+Github,搭建个性化博客","date":"2017-04-08T14:05:00.155Z","path":"2017/04/08/create-blog-by-hexo/","text":"本教程在Win10上完成的示例,Mac环境可同时参考&gt;&gt;&gt;&gt; 一.环境准备安装 Node.js1下载地址 https://nodejs.org/en/ 安装 Git1Git-1.9.5-preview20150319.exe 配置Git环境变量：123Path:..\\Git\\bin..\\Git\\libexec\\git-core 注册Github账户二.安装Hexo123456&gt; 打开 Node.js command prompt 控制台 (以管理员身份运行）&gt; 执行命令 npm install -g hexo&gt; 创建一个文件夹，如：C:\\blog，cd到blog里执行 : hexo init&gt; 继续再Blog目录下执行命令: hexo generate （hexo g 也可以），生成静态页面&gt; 启动本地服务，进行文章预览调试 : hexo server&gt; 浏览器输入 http://localhost:4000/ 三.配置Github1创建库,库名格式: 用户名.github.io 四.配置部署123456789&gt;在blog目录, 修改 _config.yml文件配置（修改后另存为UTF-8编码）:deploy: type: git repository: https://github.com/XXX/XXX.github.io.git branch: master&gt; 组件安装 ： npm install hexo-deployer-git --save &gt; 部署 hexo deploy 五.访问1https://XXX.github.io/ 六. 一些基本路径1文章在 source/_posts，编辑器可以用 Sublime，支持 markdown 语法。如果想修改头像可以直接在主题的 _config.yml 文件里面修改，友情链接，之类的都在这里 七.常用命令1234567hexo new \"postName\" #新建文章，生成指定名称的文章至 hexo\\source\\_posts\\postName.md 编辑器可以用Sublime，支持 markdown 语法 推荐一款markdown在线编辑工具(https://www.zybuluo.com/mdeditor),本机操作可使用markdownpad hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口 ,进行文章预览调试（http://localhost:4000/ ，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本 新增文章 修改文章后 依次执行以下命令123hexo clean #非必须hexo generatehexo deploy 八.更换主题主题下载：1234git clone https://github.com/litten/hexo-theme-yilia.git themes/yiliahttps://github.com/litten/hexo-theme-yilia.git 是主题路径themes/yilia 是主题目录 ,目录是否是yilia 无所谓，只要与_config.yml文件中的配置一致即可。 主题很多可自行选择。 主题配置修改123安装完成后，打开 blog\\_config.yml ，修改主题为 yiliatheme: yilia 主题配置项修改1打开 blog\\themes\\yilia 目录，编辑主题配置文件 _config.yml 更新主题12cd themes/yiliagit pull 九.域名绑定可参考这个&gt;&gt;&gt;","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]}]